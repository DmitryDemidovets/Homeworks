Опираясь на https://css-tricks.com/snippets/css/a-guide-to-flexbox/
сделать краткий конспект по flexbox
_________________________________________________________________________________________
Часть 1. Общая информация.

Модуль Flexbox направлен на обеспечение более эффективного способа компоновки, выравнивания и распределения
пространства между элементами в контейнере, даже если их размер неизвестен и/или динамичен ( отсюда и слово «гибкий»).

Основная идея гибкого макета состоит в том, чтобы дать контейнеру возможность изменять ширину/высоту (и порядок)
своих элементов, чтобы наилучшим образом заполнить доступное пространство (в основном, чтобы приспособиться ко 
всем типам устройств отображения и размерам экрана). Гибкий контейнер расширяет элементы, чтобы заполнить доступное 
свободное пространство, или сжимает их, чтобы предотвратить переполнение.

Самое главное, макет flexbox не зависит от направления, в отличие от обычных макетов (блок, который расположен 
по вертикали, и встроенный, который расположен по горизонтали). Хотя они хорошо работают для страниц, 
им не хватает гибкости для поддержки больших или сложных приложений (особенно когда речь идет 
об изменении ориентации, изменении размера, растяжении, сжатии и т. д.).

Примечание. Макет Flexbox больше всего подходит для компонентов приложения и мелкомасштабных макетов, 
тогда как макет Grid предназначен для крупномасштабных макетов.
___________________________________________________________________________________________
 Часть 2. Базовая терминология.

Поскольку flexbox — это целый модуль, а не отдельное свойство, он включает в себя множество вещей,
включая весь набор свойств. Некоторые из них предназначены для установки в контейнере (родительский элемент,
известный как «гибкий контейнер»), тогда как другие предназначены для установки в дочерних 
элементах (так называемые «гибкие элементы»).

Если «обычная» компоновка основана как на блочном, так и на встроенном направлениях потока, то гибкая 
компоновка основана на «направлениях гибкого потока».

Диаграмма, объясняющая терминологию flexbox. Размер по главной оси флексбокса называется основным размером, 
другое направление — поперечным размером. Эти размеры имеют основное начало, основной конец, поперечное начало
 и поперечный конец.
Элементы будут располагаться либо по главной оси (от начала до конца), либо по поперечной оси (от начала до конца).

главная ось — главная ось гибкого контейнера — это основная ось, вдоль которой располагаются гибкие элементы. 
Осторожно, это не обязательно горизонтально; это зависит от свойства flex-direction (см. ниже).
главный старт | main-end — flex-элементы размещаются внутри контейнера, начиная с main-start и заканчивая main-end.
основной размер — ширина или высота гибкого элемента, в зависимости от того, что находится в основном 
измерении, является основным размером элемента. Основным свойством размера гибкого элемента является свойство 
«ширина» или «высота», в зависимости от того, что находится в основном измерении.
поперечная ось – ось, перпендикулярная главной оси, называется поперечной осью. Его направление зависит от
направления главной оси.
кросс-старт | кросс-конец — гибкие линии заполняются элементами и помещаются в контейнер, начиная с кросс-стартовой 
стороны флекс-контейнера и двигаясь к кросс-концу.
поперечный размер — ширина или высота гибкого элемента, в зависимости от того, что находится в поперечном измерении,
 является поперечным размером элемента. Свойство поперечного размера — это то, что из «ширины» или «высоты» 
 находится в поперечном измерении.
_________________________________________________________________________________________
Часть 3. Свойства флексбокса.

Свойства для родительных гибких контейнеров:

1) display
Это определяет гибкий контейнер; inline или block в зависимости от заданного значения. 
Он включает гибкий контекст для всех своих прямых дочерних элементов.

2) flex-direction
Это устанавливает главную ось, тем самым определяя направление размещения гибких элементов в контейнере flex.
Flexbox — это (помимо опциональной обертки) концепция макета с одним направлением.
Думайте о гибких элементах как о расположении в первую очередь либо в горизонтальных рядах, 
либо в вертикальных столбцах.

row (default): left to right in ltr; right to left in rtl
row-reverse: right to left in ltr; left to right in rtl
column: same as row but top to bottom
column-reverse: same as row-reverse but bottom to top

3) flex-wrap
По умолчанию все flex-элементы будут пытаться разместиться на одной строке. 
Вы можете изменить это и разрешить элементам переноситься по мере необходимости с помощью этого свойства.
nowrap (default): all flex items will be on one line
wrap: flex items will wrap onto multiple lines, from top to bottom.
wrap-reverse: flex items will wrap onto multiple lines from bottom to top.

4) flex-flow
Это сокращение для свойств flex-direction и flex-wrap, 
которые вместе определяют главную и поперечную оси flex-контейнера. 
Значение по умолчанию — row nowrap.

5) justify-content
Это определяет выравнивание вдоль главной оси. Это помогает распределять дополнительное свободное пространство, 
когда либо все гибкие элементы в строке негибкие, либо гибкие, но достигли своего максимального размера. 
Он также осуществляет некоторый контроль над выравниванием элементов, когда они выходят за пределы строки.

flex-start (по умолчанию): элементы упаковываются в направлении начала flex-направления.
flex-end: элементы упаковываются ближе к концу flex-направления.
начало: элементы упаковываются в направлении начала режима записи.
конец: элементы упаковываются ближе к концу направления режима письма.
left: элементы упаковываются по направлению к левому краю контейнера, если только это не имеет смысла
с flex-direction, тогда это ведет себя как start.
right: элементы упаковываются по направлению к правому краю контейнера, если только это не имеет смысла 
с flex-direction, тогда это ведет себя как конец.
center: элементы располагаются по центру линии
space-between: элементы равномерно распределены в строке; первый элемент находится в начальной строке, 
последний элемент в конечной строке
space-round: элементы равномерно распределены в строке с равным пространством вокруг них. Обратите внимание,
что визуально пространства не равны, так как все предметы имеют одинаковое пространство с обеих сторон.
Первый элемент будет иметь одну единицу пространства от края контейнера, но две единицы пространства между
следующим элементом, потому что этот следующий элемент имеет свой собственный интервал, который применяется.
пространственно-равномерно: элементы распределяются так, чтобы расстояние между любыми двумя элементами
 (и расстояние до краев) было одинаковым.

Обратите внимание, что поддержка браузером этих значений имеет нюансы. 
Например, space-between никогда не поддерживался в некоторых версиях Edge, а start/end/left/right еще нет в Chrome.
У MDN есть подробные диаграммы. Наиболее безопасными значениями являются flex-start, flex-end и center.

Есть также два дополнительных ключевых слова, которые вы можете сочетать с этими значениями: безопасный 
и небезопасный. Использование безопасного гарантирует, что, как бы вы ни использовали этот тип позиционирования, 
вы не можете нажать элемент так, чтобы он отображался за пределами экрана (например, сверху) таким образом, 
что содержимое также не может быть прокручено (так называемая «потеря данных»). 

6) align-items
Это определяет поведение по умолчанию для того, как flex-элементы располагаются вдоль поперечной оси 
на текущей строке. Думайте об этом как о версии с выравниванием содержимого для поперечной оси 
(перпендикулярной главной оси).
stretch (default):растянуть, чтобы заполнить контейнер (по-прежнему соблюдать минимальную ширину/макс. ширину)
flex-start / start / self-start: элементы размещаются в начале поперечной оси. 
Разница между ними тонкая и заключается в соблюдении правил направления гибкости или правил режима записи.
flex-end / end / self-end: элементы размещаются в конце поперечной оси. Разница снова неуловима и 
заключается в соблюдении правил гибкого направления по сравнению с правилами режима письма.
center: элементы располагаются по центру поперечной оси
baseline: элементы выравниваются так, как их базовые линии выравниваются

Ключевые слова-модификаторы safe и unsafe можно использовать в сочетании со всеми остальными
ключевыми словами (хотя обратите внимание на поддержку браузера) и помочь вам предотвратить 
выравнивание элементов таким образом, что содержимое становится недоступным.

7) align-content

Это выравнивает строки гибкого контейнера внутри, когда на поперечной оси есть дополнительное пространство, 
аналогично тому, как justify-content выравнивает отдельные элементы внутри основной оси.
нормальный (по умолчанию): элементы упаковываются в положение по умолчанию, как если бы значение не 
было установлено.
flex-start / start: элементы упакованы до начала контейнера. (Более поддерживаемый) flex-start учитывает 
направление flex-direction, а start учитывает направление режима записи.
flex-end/end: ​​предметы упакованы до конца контейнера. flex-end (больше поддержки) учитывает направление
 flex-direction, в то время как end учитывает направление режима письма.
center: элементы в центре контейнера
пространство между: элементы распределены равномерно; первая строка находится в начале контейнера, 
а последняя в конце
space-round: элементы равномерно распределены с одинаковым пространством вокруг каждой строки
space-evenly: элементы равномерно распределены с равным пространством вокруг них
растянуть: строки растягиваются, чтобы занять оставшееся пространство

Ключевые слова-модификаторы safe и unsafe можно использовать в сочетании со всеми остальными ключевыми
совами (хотя обратите внимание на поддержку браузера) и помочь вам предотвратить выравнивание элементов 
таким образом, что содержимое становится недоступным

8) gap, row-gap, column-gap

Свойство gap явно управляет пространством между flex-элементами.
Применяется этот интервал только между элементами, не находящимися на внешнем краю
Поведение можно рассматривать как минимальный отступ, как если бы отступ каким-то образом стал больше 
(из-за чего-то вроде justify-content: space-between;), тогда зазор вступит в силу только в том случае,
 если это пространство в конечном итоге станет меньше.

Это не только для flexbox, разрыв работает и в сетке, и в многоколоночной компоновке.


Свойства для дочерних гибких элементов:

1)order- По умолчанию flex-элементы располагаются в исходном порядке. 
Однако свойство order управляет порядком, в котором они появляются в flex-контейнере.
Элементы с тем же порядком возвращаются к исходному порядку.

2) flex-grow
Это определяет способность гибкого элемента увеличиваться при необходимости. 
Он принимает безразмерное значение, которое служит пропорцией. Он определяет,
 какое количество доступного пространства внутри гибкого контейнера должен занимать элемент.

Если для всех элементов flex-grow установлен в 1, оставшееся пространство в контейнере
будет распределено поровну между всеми дочерними элементами. Если один из дочерних 
элементов имеет значение 2, этот дочерний элемент будет занимать в два раза больше места, 
чем один из других (или, по крайней мере, попытается).
 
3) flex-shrink
Это определяет способность гибкого элемента сжиматься при необходимости.

Отрицательные числа недействительны.

4) flex-basis
Это определяет размер элемента по умолчанию до распределения оставшегося пространства. 
Это может быть длина (например, 20%, 5rem и т. д.) или ключевое слово. Ключевое слово auto
означает «посмотрите на мое свойство ширины или высоты» (что временно выполнялось ключевым словом main-size, 
оно не стало устаревшим). Ключевое слово content означает «размер на основе 
содержимого элемента» — это ключевое слово еще недостаточно хорошо поддерживается, поэтому его трудно 
протестировать и еще труднее узнать, что делают его собратья max-content, min-content и fit-content.

Если установлено значение 0, дополнительное пространство вокруг контента не учитывается. 
Если установлено значение auto, дополнительное пространство распределяется на основе его значения
flex-grow. См. этот рисунок

5) flex
Это сокращение для flex-grow, flex-shrink и flex-basis вместе взятых. 
Второй и третий параметры (flex-shrink и flex-basis) являются необязательными. 
По умолчанию 0 1 auto, но если вы установите его с помощью одного числового значения,
например flex: 5;, это изменит flex-basis на 0%, так что это похоже на установку
flex-grow: 5; гибкая термоусадка: 1; flex-база: 0%;.

Рекомендуется использовать это сокращенное свойство, а не задавать отдельные свойства.
Сокращение разумно устанавливает другие значения.

6) align-self
Это позволяет переопределить выравнивание по умолчанию (или указанное align-items) для отдельных 
flex-элементов.

Пожалуйста, смотрите объяснение align-items, чтобы понять доступные значения

Обратите внимание, что float, clear и vertical-align не влияют на flex-элемент.

_________________________________________________________________________________________
Часть 4. Префиксинг флексбокса.


Flexbox требует префикса поставщика для поддержки большинства возможных браузеров. 
Он не просто включает свойства с префиксом поставщика, но на самом деле это совершенно другие имена
свойств и значений. Это связано с тем, что спецификация Flexbox менялась с течением времени, создавая 
«старую», «твинерную» и «новую» версии.

Возможно, лучший способ справиться с этим — написать новый (и окончательный) синтаксис и запустить свой
CSS через Autoprefixer, который очень хорошо обрабатывает запасные варианты.

В качестве альтернативы, вот Sass @mixin, чтобы помочь с некоторыми префиксами, который также дает вам
представление о том, какие вещи нужно сделать:

